# 15. 구글 드라이브 설계

<br/><br/>

# 1단계 : 문제 이해 및 설계 범위 확정

<br/>

- **질문 :** 가장 중요하게 지원해야 할 기능들은 무엇인가요 ?
  - **답 :** 파일 업로드, 다운로드, 파일 동기화, 그리고 알림입니다.
- **질문 :** 모바일 앱/웹 둘 다 지원해야 하나요 ?
  - **답 :** 네
- **질문 :** 파일을 암호화해야 하나요 ?
  - **답 :** 네
- **질문 :** 파일 크기에 제한이 있나요?
  - **답 :** 10GB 제한이 있습니다.
- **질문 :** 사용자는 얼마나 됩니까 ?
  - **답 :** 일간 능동 사용자(DAU) 기준 천만 명입니다.
- **비-기능적 요구사항**
  - **안정성 :** 저장소 시스템에서 안정성은 아주 중요합니다. 데이터 손실은 절대 없어야 합니다.
  - **빠른 동기화 속도 :** 파일 동기화에 시간이 많이 걸리면 사용자는 인내심을 잃고 해당 제품을 더 이상 사용하지 않게 됩니다.
  - **네트워크 대역폭 :** 이 제품이 네트워크 대역폭을 불필요하게 많이 소모한다면 사용자에게 좋지 않습니다.
  - **규모 확장성 :** 이 시스템은 아주 많은 양의 트래픽도 처리 가능해야 합니다.
  - **높은 가용성 :** 일부 서버에 장애가 발생하거나, 느리거나, 네트워크 일부가 끊겨도 시스템은 계속 이용 가능해야 합니다.
- **개략적 추정치**
  - 가입 사용자는 오천만 명이고, 천만 명의 DAU 사용자가 있다고 가정
  - 모든 사용자에게 10GB의 무료 저장 공간 할당
  - 매일 각 사용자가 평균 2개의 파일을 업로드한다고 가정, 각 파일의 평균 크기는 500KB
  - 읽기 쓰기 비율은 1 : 1로 가정
  - 필요 저장 공간 = 5천만 \* 10GB = 500페타 바이트
  - 업로드 API QPS = 천만 명 \* 2개 파일 / 24 / 60 = 약 240
  - 최대 QPS = 240 \* 2 = 480

<br/><br/>

# 2단계 : 개략적 설계안 제시 및 동의 구하기

<br/>

## API

1. **파일 업로드 API**

- **단순 업로드 :** 파일 크기가 작을 때 사용합니다.
- **이어 올리기(resumable upload) :** 파일 사이즈가 크고 네트워크 문제로 업로드가 중단될 가능성이 높다고 생각될 때 사용합니다.
  - 예시 : https://api.example.com/files/upload?uploadType=resumable
  - 실행 단계 : 이어 올리기 URL을 받기 위한 최초 요청 전송 → 데이터를 업로드하고 업로드 상태 모니터링 → 업로드 장애 시 장애 시점부터 업로드 재시작

2. **파일 다운로드 API**

- 예시 : https://api.example.com/files/download
- api 인자 : path(다운로드할 파일의 경로)

3. **파일 갱신 히스토리 API**

- 예시 : https://api.example.com/files/list_revisions
- api 인자 : path(갱신 히스토리를 가져올 파일의 경로) , limit(히스토리 길이의 최대치)

<br/>

## 동기화 충돌

- 대형 저장소 시스템의 경우 동기화 충돌이 발생할 수 있습니다. 특정 파일을 같은 아이디로 A가 수정하고, B가 수정했을 때, 먼저 처리된 것은 동기화 완료로 응답을 내려주고, 나중에 온 것은 충돌이 발생했다고 응답을 내려줍니다. 이때 충돌이 발생한 브라우저의 경우, 기존 것을 없앨지, 내 것을 없앨지 선택할 수 있습니다.

<br/>

## 개략적 설계안

![image](15-1.png)

- **블록 저장소 서버(Block server) :** 파일 블록을 클라우드 저장소에 업로드하는 서버입니다. 클라우드 환경에서 데이터 파일을 저장하는 기술입니다. 이 저장소는 파일을 여러 개의 블록으로 나눠 저장하며 각 블록에는 고유한 해시값이 할당됩니다. 이 해시값은 메타데이터 데이터베이스에 저장됩니다. 각 블록은 독립적인 객체로 취급되며 클라우드 저장소 시스템(S3)에 저장됩니다. 파일을 재구성하려면 블록들을 원래 순서대로 합쳐야 합니다. 예시에서 한 블록은 4MB로 임의로 정했습니다.
- **클라우드 저장소 :** 파일은 블록 단위로 나눠져 클라우드 저장소(S3)에 저장됩니다. S3를 파일 저장소로 활용하고 가용성과 데이터 무손실을 보장하기 위해 두 개 이상의 지역에 데이터를 다중화합니다.
- **아카이빙 저장소 :** 오랜 기간 사용하지 않은 비활성 데이터를 저장하기 위한 컴퓨터 시스템입니다.
- **로드밸런서 :** 네트워크 트래픽을 분산하기 위해 사용하며 특정 서버 장애 시 자동으로 해당 서버를 우회합니다.
- **API 서버 :** 파일 업로드 외에 거의 모든 것을 담당하는 서버로 사용자 인증, 사용자 프로파일 관리, 파일 메타데이터 갱신 등에 사용됩니다.
- **메타데이터 데이터베이스 :** 사용자, 파일, 블록, 버전 등의 메타데이터 정보를 관리합니다. 실제 파일은 클라우드에 보관하고 이 데이터베이스에는 오직 메타데이터만 둔다는 것을 명심해야 합니다. 또한, 다중화 및 샤딩 정책을 적용해 가용성과 규모 확장성 요구사항에 대응합니다.
- **메타데이터 캐시 :** 성능 향상을 위해 자주 쓰이는 메타데이터는 캐시 합니다.
- **알림 서비스 :** 파일 추가, 편집, 삭제 등 이벤트 발생 시 클라이언트에게 알리는데 쓰이는 발생/구독 프로토콜 기반 시스템입니다.
- **오프라인 사용자 백업 큐 :** 클라이언트가 접속 중이 아니라서 파일의 최신 상태를 확인할 수 없을 때는 해당 정보를 이 큐에 두어 나중에 클라이언트가 접속했을 때 동기화될 수 있도록 합니다.

<br/><br/>

# 3단계 : 상세설계

<br/>

## 블록 저장소 서버

- 정기적으로 갱신되는 큰 파일들은, 업데이트가 일어날 때마다 전체 파일을 서버로 보내면 네트워크 대역폭을 많이 잡아먹어, 이를 위해 아래 방법을 고려합니다.
  - **델타 동기화(Delta sync) :** 파일이 수정되면 전체 파일 대신 수정이 일어난 블록만 동기화합니다.
  - **압축 :** 블록 단위로 압축해 두면 데이터 크기를 많이 줄일 수 있습니다. 압축 알고리즘은 파일 유형에 따라 다릅니다. 텍스트 파일 압축 시 gzip, bzip2를 사용합니다.
- 블록 저장소 서버는 파일 업로드에 관계된 힘든 일을 처리하는 컴포넌트입니다. 클라이언트가 보낸 파일을 블록 단위로 분할하고, 각 블록에 압축 알고리즘 적용 및 암호화까지 합니다. 아울러 전체 파일을 저장소 시스템으로 보내는 대신 수정된 블록만 전송해야 합니다.

![image](15-2.png)

<br/>

## 높은 일관성 요구사항

- 메타데이터 캐시와 데이터베이스 계층에서 높은 일관성이 적용되어야 합니다. 관계형 데이터베이스는 ACID(Atomicity, Consistency, Isolation, Durability)를 보장하므로 관계형 데이터베이스를 사용합니다. NoSQL 데이터베이스는 이를 기본으로 지원하지 않습니다.

<br/>

## 메타데이터 데이터베이스

- 간추린 데이터베이스의 스키마입니다.

![image](15-3.png)

- **user :** 해당 테이블에는 이름, 이메일, 프로필 사진 등 기본 정보가 저장됩니다.
- **device :** 해당 테이블에는 단말 정보가 저장됩니다. 한 사용자가 여러 단말을 가질 수 있습니다. 모바일 푸시 알림을 보내고 받을 push_id도 여기 저장됩니다.
- **namespace :** 해당 테이블에는 사용자의 루트 디렉터리 정보가 보관됩니다.
- **file :** 해당 테이블에는 파일의 최신 정보가 저장됩니다.
- **file_version :** 파일 갱신 이력이 보관되는 테이블입니다. 이 테이블은 이력 훼손을 방지하기 위해 읽기 전용으로 만듭니다.
- **block :** 파일 블록에 대한 정보를 보관하는 테이블입니다. 특정 버전의 파일은 파일 블록을 올바른 순서로 조합하기만 하면 복원할 수 있습니다.

<br/>

## 업로드 절차

![image](15-4.png)

- 위 시퀀스 다이어그램은 클라이언트 [1]이 두 개의 요청이 병렬적으로 전송된 상황을 보여줍니다. 첫 번째 요청은 **파일 메타데이터를 추가**하기 위한 것, 두 번째는 **파일을 클라우드 저장소로 업로드하기 위한 것**입니다.
- **파일 메타데이터 추가**
  - 클라이언트 [1]이 새 파일의 메타데이터를 추가하기 위해 요청을 보냅니다.
  - 새 파일의 메타데이터를 데이터베이스에 저장하고 업로드 상태를 대기 중(pending)으로 변경합니다.
  - 새 파일이 추가되었음을 알림 서비스에 통지합니다. 이때, 클라이언트 2에게 파일이 업로드되고 있음을 알립니다.
- **파일을 클라우드 저장소에 업로드**
  - 클라이언트 [1]이 파일 [블록 저장소 서버]에 파일을 업로드합니다.
  - [블록 저장소 서버]는 파일을 블록 단위로 쪼갠 다음 압축, 암호화한 후 [클라우드 저장소]에 전송합니다.
  - 업로드가 끝나면 클라우드 스토리지는 완료 콜백을 호출, 이 콜백 호출은 API 서버로 전송됩니다.
  - 메타데이터 DB에 기록된 해당 파일의 상태를 완료로 변경합니다.
  - 파일 업로드가 끝났음을 알림 서비스에 통지하고, 알림 서비스는 관련된 클라이언트 [2]에게 파일 업로드가 끝났음을 알립니다.

<br/>

## 다운로드 절차

![image](15-5.png)

- 1. 알림 서비스가 클라이언트 2에게 누군가 파일을 변경했음을 알립니다.
- 2. 알림을 확인한 클라이언트 2는 새로운 메타데이터를 요청합니다.
- 3. API 서버는 메타데이터 데이터베이스에게 새 메타데이터를 요청합니다.
- 4. API 서버에게 새 메타데이터가 반환됩니다.
- 5. 클라이언트 2에게 새 메타데이터가 반환됩니다.
- 6. 클라이언트 2는 새 메타데이터를 받는 즉시 블록 다운로드 요청을 전송합니다.
- 7. 블록 저장소 서버는 클라우드 저장소에서 블록을 다운로드합니다.
- 8. 클라우드 저장소는 블록 서버에 요청된 블록을 반환합니다.
- 9. 블록 저장소 서버는 클라이언트에게 요청된 블록을 반환하고, 클라이언트 2는 전송된 블록을 사용해 파일 재구성합니다.

<br/>

## 알림 서비스

- 파일 일관성을 위해 클라이언트는 파일이 수정 감지 시 즉각 적으로 다른 클라이언트에게 알려 충돌 가능성을 줄여야 합니다. 알림 서비스는 이벤트 데이터를 클라이언트들로 보내는 서비스입니다.
- **롱 폴링(Long polling)**
  - 롱 폴링은 클라이언트와 서버 간의 실시간 통신을 가능하게 하는 방법으로, 일반적인 폴링은 클라이언트가 서버에 주기적으로 요청을 보내고, 서버는 클라이언트에게 즉시 응답하는데, 롱 폴링은 이와 달리 클라이언트가 서버에 요청을 보내면, 서버는 요청이 있을 때까지 응답을 대기하다가 이벤트가 발생하면 클라이언트에게 그제서야 응답을 보내는 방식입니다. 롱 폴링은 “요청 → 응답 → 끊김 → 재요청”의 구조입니다.
  - 모든 클라이언트는 알림 서버에 롱 폴링 요청을 보내고 기다림 → A 클라이언트가 파일을 수정, 메타데이터 서버에 변경 내역을 반영, 그 후 알림 서버에 알림 이벤트 발생 →알림 서버는 롱 폴링 중이던 B, C 클라이언트에게 응답을 보내 파일이 바뀌었음을 알림 → B, C 클라이언트는 그럼 해당 롱 폴링 연결을 끊음(변경이 있을 때만 응답이 오기 때문) → B, C 클라이언트는 메타데이터 서버에 파일 최신 내역 요청 후 다운로드 → B, C는 다시 알림 서버에 롱 폴링 요청을 보냄

<br/>

## 저장소 공간 절약

- 안정성 보장과 갱신 이력 보존을 위해 여러 데이터센터에 데이터를 보관합니다. 이때 모든 정보를 실시간으로 백업하면 저장용량이 빨리 소진됩니다. 이런 문제를 피하고 비용 절감을 위해 아래 3가지 방법을 사용합니다.
- **중복 제거 :** 중복된 파일 블록을 계정 차원에서 제거하는 방법으로 두 블록이 같은지는 해시 값을 비교해 판단합니다.
- **지능적 백업 전략**
  - 파일 버전 개수에 상한을 두어 상한에 도달하면 오래된 버전을 버립니다.
  - 중요한 버전만 보관
- 몇 달 혹은 수년간 자주 쓰이지 않는 데이터는 아카이빙 저장소로 옮깁니다.(ex. 아마존 S3 glacier)

<br/>

## 장애 처리

- **로드밸런서 장애 :** 로드밸런서 장애 시 부(secondary) 로드밸런서가 활성화되어 트래픽을 이어받아야 합니다. 로드 밸런서끼리는 보통 박동(heart beat) 신호를 주기적으로 보내 상태를 모니터링합니다. 일정 시간 응답하지 않으면 장로 간주합니다.
- **블록 저장소 서버 장애 :** 블록 저장소 서버에 장애 발생 시 다른 서버가 미완료 상태 또는 대기 상태인 작업을 이어받아야 합니다.
- **클라우드 저장소 장애 :** S3 버킷은 여러 지역에 다중화가 가능해서 한 지역 장애 시 타 지역에서 가져올 수 있습니다.
- **API 서버 장애 :** API 서버들은 무상태 서버입니다. 따라서 로드밸런서는 API 서버 장애 시 해당 서버에 트래픽을 보내지 않음으로 해당 서버를 격리합니다.
- **메타데이터 캐시 장애 :** 메타데이터 캐시 서버도 다중화합니다. 장애 발생 시 다른 노드에서 데이터를 가져오고, 장애 서버를 새 서버로 교체합니다.
- **메타데이터 데이터베이스 장애**
  - **주 데이터베이스 서버 장애 :** 부 데이터베이스 서버 가운데 하나를 주로 바꾸고, 부를 새로 추가
  - **부 데이터베이스 서버 장애 :** 다른 부 서버에서 읽기 연산을 처리토록 하고 장애 서버는 새것으로 교체
- **알림 서비스 장애 :** 알림 서비스에 장애가 발생하면 클라이언트와 서버 간 롱 폴링 연결이 끊어질 텐데, 롱 폴링을 서버 측에서는 재 시작이 불가하므로 빨리 고치는 방법밖에 없다.
- **오프라인 사용자 백업 큐 장애 :** 이 큐도 다중화해 장애 발생 시 구독 중인 클라이언트들은 백업 큐로 구독 관계를 재설정해야 합니다.

<br/><br/>

# 4단계 : 마무리

- 블록 저장소 서버를 거치지 않고 파일을 클라우드 저장소에 직접 올리는 방안 고려
  - 업로드 시간은 빨라지나, 분할, 압축, 암호화 로직을 클라이언트에 두어야 하므로 구현이 많아지고, 클라이언트 해킹 시 암호화 로직에 피해를 볼 수 있어 적절치 않음
