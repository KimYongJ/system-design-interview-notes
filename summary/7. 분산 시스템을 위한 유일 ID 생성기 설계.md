# 7. 분산 시스템을 위한 유일 ID 생성기 설계

<br/><br/>

# 1단계 : 문제 이해 및 설계 범위 확정

- **질문 :** ID는 어떤 특성을 갖나요?( **답 :** 유일하며 정렬 가능해야 합니다 )
- **질문 :** 새로운 레코드에 붙일 ID는 항상 1만큼 큰 값이어야 하나요?( **답 :** 그렇진 않으나 크긴 커야 합니다 )
- **질문 :** 숫자로만 구성돼야 하나요? ( **답 :** 네 )
- **질문 :** 시스템 규모는 어느 정도입니까? ( **답 :** 초당 만개의 ID를 생성할 수 있어야 합니다 )

# 2단계 : 개략적 설계안 제시 및 동의 구하기

<br/><br/>

## 분산 시스템에서 유일성 보장 ID를 만드는 방법 4가지

<br/>

### 1) 다중 마스터 복제

- 데이터베이스의 auto_increment 기능을 활용하여 ID 값을 데이터 베이스 수만큼 증가시켜 데이터베이스마다 ID 값이 중복되지 않게 하는 것입니다. (2개의 데이터베이스가 있다면 하나는 홀수 생성, 다른 것은 짝수 생성 등)
- 단점 : 여러 데이터 센터에 걸쳐 규모를 늘리기 어렵고, 시간 흐름에 맞추어 커지도록 보장할 수 없으며, 서버 추가, 삭제 시 잘 작동하기 어렵습니다.

<br/>

### 2) UUID

- 각 웹 서버는 별도의 ID 생성기를 사용해 독립적으로 ID를 만들어냅니다. 이 방법은 단순하며 동기화 이슈가 없고 각 서버가 쓸 ID를 스스로 만들기에 확장에 유리합니다.
- 단점 : 128bit로 크기가 큽니다. 시간순으로 정렬이 불가하고 숫자가 아닌 값이 포함될 수 있습니다.

<br/>

### 3) 티켓 서버

- ID를 발행하는 서버를 하나 두고 모든 서버는 해당 ID 발행 서버에 요청하여 ID를 받습니다. 유일성이 보장되며 숫자로만 구성된 ID 생성이 가능합니다. 구현이 쉽고 중소 애플리케이션에 적합합니다.
- 단점 : 티켓 서버가 SPOF(Single Point of Failure)가 됩니다. 티켓 서버를 여러 개 준비하면 동기화 문제가 발생합니다.

<br/>

### 4) 트위터 스노 플레이크 접근법

- 생성할 ID의 64bit를 5가지 의미로 쪼깨어 생성합니다.

<br/><br/>

# 3단계 : 상세 설계( 트위터 스노 플레이크 )

![image](image/7-1)

- ID 생성기를 트위터 스노플레이크 접근법으로 설계합니다. ID는 총 5개의 섹션으로 나뉩니다.

<br/>

### 1) 사인(sing) 비트

- 1비트를 할당하며 별도로 쓰진 않으나 음수 양수 구별 시 사용합니다.

<br/>

### 2) 타임스탬프

- 41비트이며 기원 시각 이후 몇 밀리초가 경과했는지를 나타내는 값입니다. 타임스탬프의 최댓값은 대략 69년에 해당합니다. 69년 후에는 기원 시각을 바꾸거나 다른 ID 체계로 이전해야 합니다.

<br/>

### 3) 데이터센터 ID

- 5비트로, 2의 5승(32) 개 데이터센터를 지원할 수 있습니다.

<br/>

### 4) 일련번호

- 일련번호는 12비트로 4096개의 값을 가질 수 있으며 각 서버에서는 ID를 생성할 때마다 이 일련번호를 1만큼 증가시킵니다. 이 값은 1밀리초 경과 시마다 0으로 초기화됩니다.

<br/><br/>

# 4단계 : 마무리

- 요구사항에 대해 트위터 스노 플레이크 방식을 사용했다면 이 과정에서 생각할 아래 문제에 대해 마지막으로 토론하면 좋습니다.
  - 시계 동기화 : 하나의 서버가 여러 코어에서 실행되거나, 여러 서버가 물리적으로 다를 때 시계 동기화 방법이 필요합니다 (NTP)
  - 각 섹션의 길이 최적화 : 예를 들어 동시성이 낮고 수명이 긴 애플리케이션이라면 일련번호 절의 길이를 줄이고 타임스탬프 절의 길이를 늘리는 것이 효과적일 수 있습니다.
  - 고가용성 : ID 생성기는 필수 불가결 컴포넌트이므로 높은 가용성을 제공해야 합니다.

---
